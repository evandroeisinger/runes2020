Introduction to Go and TDD
A short workshop
12 Oct 2019
Tags: golang, tdd, testing, unicode

Luciano Ramalho
Principal Consutant, ThoughtWorks
luciano.ramalho@thoughtworks.com
https://standupdev.com/
@ramalhoorg

* Generating named characters

* Unassigned and unnamed characters

Unicode has room for 1,114,111 _code_points_, from U+0000 to U+10FFFF. About 10% of those code points have characters assigned to them as of 2019.

Among the assigned characters, more than 70% are CJK (Chinese/Japanese/Korean) ideographs that don't have names. For example, here is what the `runenames.Name` function says about the traditional Chinese character 氣 (qi), representing vital energy:

.play -edit assets/qi.go

* Ranges of characters with generic names

.play -edit assets/noname.go

* Scanning the UCD

Given a `rune` value, `runenames.Name` returns:

- an empty string, if the code point is unnassigned;
- a string delimited by `<…>`, if the code point is part of a range of unnamed characters; 
- a unique character name — this is what we want.

We'll code `Scanner` object that will produce the code point and the name of each character that has a unique name, skipping all the others.

The values produced by `scan` will be structs (records) of this type:

    type CharName struct {
        Char rune
        Name string
    }

*NOTE*: public field names must start with an uppercase letter.

* Lab 2.1: A printable struct

*1.* Add this struct declaration to `runes/main.go`:

    type CharName struct {
        Char rune
        Name string
    }

*2.* Add this test to `runes/main_test.go`:

    func Test_CharName_String(t *testing.T) {
        want := "U+0041\tA\tLATIN CAPITAL LETTER A"
        cn := CharName{'A', "LATIN CAPITAL LETTER A"}
        got := fmt.Sprint(cn)
        assert.Equal(t, want, got)
    }

(lab continues...)

* Lab 2.1: A printable struct (continued)

*3.* To pass the test in the previous slide, you need to add a `String` method after the `CharName` struct in `main.go`. The method should have the signature shown below. Use a `fmt.Sprintf` call to build the string, similar to the `fmt.Printf` call already present in the `report` function.

    func (cn CharName) String() string {
        // return a string like this: U+XXXX<tab>Y<tab>NAME OF CHARACTER Y
    }

*NOTE*: In contrast with functions, method signatures declare the target object in parenthesis right after the `func` keyword. In the example above, `cn` plays the role of the special variables `this` or `self` in other languages.



* Iterators in Go

As of 2019, Go does not provide a way to implement user-defined iterators supported by the `for` `…` `range` syntax. Here are two common patterns we use to work around this limitation:

- Implement the classic iterator pattern: an object with two methods and an internal counter. One method advances the counter, returning `false` when there are no more items. The other returns the next item. Client code uses the iterator like this:

    iterator := MyIterator(iterable)
    for iterator.Advance() {
        value := iterator.Next()
        doSomethingWith(value)
    }

- Implement a function that spaws a coroutine to send items one by one through a channel, return that channel . Client code reads the channel using clean `for` `…` `range` syntax. This implementation is simpler. However, there is a context switch cost to run a coroutine, and the coroutine may _leak_ if it does not run to completion.

* Iterator implementations compared

.image assets/iterators/iterators-compared.png 500 _

Source: `github.com/standupdev/runes2019/step02/assets/iterators/...`










